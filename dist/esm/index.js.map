{
  "version": 3,
  "sources": ["../../src/hooks/useInjector.ts", "../../src/util/helpers.ts", "../../src/AfterthoughtService.ts", "../../src/util/Dispatcher.ts", "../../src/createInjector.ts", "../../src/AfterthoughtProvider.tsx", "../../src/hooks/useService.ts"],
  "sourcesContent": ["import {useContext} from \"react\";\nimport {AfterthoughtInjector, AfterthoughtServices} from \"../types\";\nimport {AfterthoughtContext} from \"../AfterthoughtProvider\";\n\nexport function useInjector<TService = AfterthoughtServices>(): AfterthoughtInjector<TService> {\n\tconst contextValue = useContext(AfterthoughtContext)\n\n\tif (__DEV__ && !contextValue) {\n\t\tthrow new Error(\n\t\t\t'could not find <TODO_NAME> context value; please ensure the component is wrapped in a <Provider>'\n\t\t)\n\t}\n\n\treturn contextValue as any;\n}\n", "import React from \"react\";\nimport {SYM_PROXY_INDICATOR, SYM_WATCHES} from \"../AfterthoughtService\";\n\n/**\n * @internal\n */\nexport interface ReactRenderingTracker {\n\tget isRendering(): boolean;\n\tnotifyIsRendering(): void;\n\n\t/**\n\t * Resets the tracker back to initial state (not rendering).\n\t */\n\treset(): void;\n}\n\n/**\n * @internal\n */\nexport function createRenderingTracker(): ReactRenderingTracker {\n\tlet handle = null;\n\treturn {\n\t\tget isRendering(): boolean {\n\t\t\treturn handle !== null;\n\t\t},\n\t\tnotifyIsRendering(): void {\n\t\t\tif(handle === null) {\n\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\thandle = null\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\treset() {\n\t\t\tif(handle) {\n\t\t\t\tclearTimeout(handle);\n\t\t\t\thandle = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function getWatches(service: any): Set<string> {\n\treturn service[SYM_WATCHES];\n}\n\n\n/**\n * Gets the current components name\n * @__PURE__\n * @internal\n */\nexport function currentRenderingComponentName(): string | undefined {\n\tif(!__DEV__) {\n\t\treturn undefined;\n\t} else {\n\t\treturn React['__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'].ReactCurrentOwner.current?.elementType?.name;\n\t}\n}\n\n/**\n * Lightweight logging\n * @internal\n * @param args\n */\nexport function debug(...args: any[]) {\n\tif(__DEV__) {\n\t\t// @ts-ignore\n\t\tconsole.debug(...args)\n\t}\n}\n", "import {AfterthoughtInjector, AfterthoughtServices} from \"./types\";\n\n/**\n * @internal - Private method for internal use only\n */\nexport const SYM_PROXY_INDICATOR = Symbol('rs_proxy');\n/**\n * @internal - Private method for internal use only\n */\nexport const SYM_WATCHES = Symbol('rs_watches');\n\nexport class AfterthoughtService<TServices = AfterthoughtServices> {\n\tget services(): TServices {\n\t\t// this will be overwritten by our service proxy\n\t\tthrow new Error('Service not correctly initialized through Afterthought provider, services are unavailable. This is likely a bug')\n\t}\n}\n", "import {ServiceHistory} from \"../types\";\n\nexport interface DispatchHandler<T> {\n\t(data: T): any;\n}\n\n/**\n * Basic doubly linked list, use this because it's easy to remove itself without affecting other nodes position\n */\nclass ListNode<T> {\n\tnext?: ListNode<T>\n\tprev?: ListNode<T>\n\n\tconstructor(\n\t\tpublic readonly data: T\n\t) {}\n\n\tadd(node: ListNode<T>) {\n\t\tconst pn = this.next;\n\t\tthis.next = node;\n\t\tnode.next = pn;\n\t\tnode.prev = this;\n\t}\n\n\tremoveSelf() {\n\t\tif(this.next)\n\t\t\tthis.next.prev = this.prev;\n\t\tif(this.prev)\n\t\t\tthis.prev.next = this.next;\n\n\t\tthis.next = undefined;\n\t\tthis.prev = undefined;\n\t}\n}\n\nexport class Dispatcher<T = ServiceHistory> {\n\tprivate readonly handlersHead = new ListNode<DispatchHandler<T>>(null);\n\n\temit(data: T) {\n\t\t// go next right away cause handlersHead is always a placeholder node\n\t\tlet node = this.handlersHead.next;\n\t\twhile(node) {\n\t\t\tnode.data(data);\n\t\t\tnode = node.next;\n\t\t}\n\t}\n\n\tsubscribe(callback: DispatchHandler<T>) {\n\t\tconst newNode = new ListNode(callback);\n\n\t\tthis.handlersHead.add(newNode);\n\n\t\treturn () => {\n\t\t\tnewNode.removeSelf();\n\t\t}\n\t}\n}\n", "import {\n\tAfterthoughtInjector,\n\tToServiceInstance,\n\tAfterthoughtServices,\n\tClassConstructor, ValidServiceKey, ServiceHistory, ServiceInstances, ServiceDefinitions\n} from \"./types\";\nimport {\n\tcreateRenderingTracker,\n\tcurrentRenderingComponentName,\n\tdebug, ReactRenderingTracker,\n} from \"./util/helpers\";\nimport {Dispatcher, DispatchHandler} from \"./util/Dispatcher\";\nimport {AfterthoughtService, SYM_PROXY_INDICATOR, SYM_WATCHES} from \"./AfterthoughtService\";\n\n\nexport function createInjector<TServices = AfterthoughtServices>(services: TServices): AfterthoughtInjector<TServices> {\n\treturn new AfterthoughtInjectorImpl<TServices>(services as any)\n}\n\nfunction unwrapProxy(obj: any) {\n\tif(Array.isArray(obj)) {\n\t\treturn obj.map(unwrapProxy);\n\t} else if(obj) {\n\t\tlet v = obj[SYM_PROXY_INDICATOR];\n\t\tif(v) return v;\n\t}\n\n\treturn obj;\n}\n\nclass AfterthoughtInjectorImpl<TServices = AfterthoughtServices> implements AfterthoughtInjector<TServices> {\n\tpublic readonly _renderingTracker = createRenderingTracker();\n\n\tpublic readonly services: ServiceInstances<TServices> = createServiceProxy(this);\n\tprivate readonly serviceNames = new Map<string, any>();\n\tprivate readonly dispatcher = new Dispatcher();\n\tprivate readonly serviceInstances = new Map<any, {\n\t\tinstance: any,\n\t\ttype: any,\n\t\tname: string\n\t}>;\n\tprivate readonly injectorContext: ServiceContext = {\n\t\trenderingTracker: this._renderingTracker,\n\t\tdispatcher: this.dispatcher\n\t}\n\n\n\tconstructor(\n\t\tconfig: ServiceDefinitions<TServices>\n\t) {\n\t\tfor (let key in config) {\n\t\t\tthis.serviceNames.set(key, config[key]);\n\n\t\t\tthis.serviceInstances.set(config[key], {\n\t\t\t\tinstance: this.initService(config[key]),\n\t\t\t\ttype: config[key],\n\t\t\t\tname: key,\n\t\t\t})\n\t\t}\n\n\n\t\tif(__DEV__) {\n\t\t\tthis.dispatcher.subscribe(({path}) => {\n\t\t\t\tdebug('RS-Change', path);\n\t\t\t})\n\t\t}\n\t}\n\n\tsubscribe(callback: DispatchHandler<ServiceHistory>): () => void {\n\t\treturn this.dispatcher.subscribe(callback);\n\t}\n\n\tgetService<T extends ValidServiceKey<TServices>>(service: T): ToServiceInstance<T, TServices> {\n\t\treturn this.initServiceProxy(service).proxy;\n\t}\n\n\t_getDerivedService<T extends ValidServiceKey<TServices>>(service: T, context: ProxyContext): ToServiceInstance<T, TServices> {\n\t\treturn this.initServiceProxy(service, context).proxy;\n\t}\n\n\tprivate initServiceProxy(service: ValidServiceKey<TServices>, context?: ProxyContext) {\n\t\tif (typeof service === 'string') {\n\t\t\tservice = this.serviceNames.get(service);\n\t\t}\n\n\t\tconst entry = this.serviceInstances.get(service);\n\t\tif (!entry) {\n\t\t\tthrow new Error('Unregistered service ' + String(service));\n\t\t}\n\n\t\tif(!context) {\n\t\t\tcontext = createProxyContext();\n\t\t}\n\n\t\tconst proxyHandler = new ObjectProxyHandler(entry.instance, entry.name, createServiceProxy(this, context), this.injectorContext, context)\n\n\t\treturn {\n\t\t\tproxy: new Proxy(entry.instance, proxyHandler),\n\t\t\tproxyHandler,\n\t\t};\n\t}\n\n\tprivate initService(service: ClassConstructor | object) {\n\t\tlet instance;\n\t\tif (this.isConstructor(service)) {\n\t\t\ttry {\n\t\t\t\tinstance = new service();\n\t\t\t} catch (e) {\n\t\t\t\tif (!e || e.name !== 'TypeError' ||\n\t\t\t\t\t!(typeof e.message === 'string' && e.message.endsWith('is not a constructor'))) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} else {\n\t\t\t\t\tinstance = service;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tinstance = service;\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\tprivate isConstructor(v: any): v is new() => any {\n\t\treturn typeof v === 'function' && v?.prototype?.constructor\n\t}\n}\n\n\nfunction createServiceProxy(injector: AfterthoughtInjectorImpl<any>, proxyContext: ProxyContext = undefined) {\n\treturn new Proxy({}, {\n\t\tget(target: any, p: string | symbol, receiver: any): any {\n\t\t\tif (typeof p === 'string') {\n\t\t\t\treturn injector._getDerivedService(p, proxyContext);\n\t\t\t} else {\n\t\t\t\treturn target[p];\n\t\t\t}\n\t\t},\n\t\tset(target: any, p: string | symbol, newValue: any, receiver: any): boolean {\n\t\t\tthrow new Error('Cannot set a service here, services must be registered.')\n\t\t}\n\t})\n}\n\ntype ServiceContext = {\n\trenderingTracker: ReactRenderingTracker,\n\tdispatcher: Dispatcher,\n};\n\ntype ProxyContext = ReturnType<typeof createProxyContext>;\nfunction createProxyContext() {\n\treturn {\n\t\twatches: new Set<string>(),\n\t\tservicesRef: { value: null }\n\t}\n}\n\nclass ObjectProxyHandler implements ProxyHandler<any> {\n\tpublic readonly proxies = new WeakMap<any, any>();\n\n\tconstructor(\n\t\tpublic readonly target: any,\n\t\tpublic readonly path: string,\n\t\tpublic readonly services: any,\n\t\tpublic readonly serviceContext: ServiceContext,\n\t\tpublic readonly proxyContext: ProxyContext,\n\t) {\n\t}\n\n\tget(target: object, p: string | symbol, receiver: any): any {\n\t\tif(p === SYM_PROXY_INDICATOR) {\n\t\t\treturn this.target;\n\t\t} else if(p === SYM_WATCHES) {\n\t\t\treturn this.proxyContext.watches;\n\t\t} else if (p === 'services' && this.services) {\n\t\t\treturn this.services;\n\t\t}\n\n\t\tlet result;\n\t\tconst propPath = this.pathForProp(p);\n\t\tif (typeof target[p] === 'function') {\n\t\t\tresult = target[p];\n\t\t} else if (target[p] !== null && typeof target[p] === 'object') {\n\t\t\tif (!this.proxies.has(target[p]) || this.proxies.get(target[p]) == null) {\n\t\t\t\tthis.proxies.set(target[p], new Proxy(target[p], new ObjectProxyHandler(target[p], propPath, null, this.serviceContext, this.proxyContext)));\n\t\t\t}\n\t\t\tresult = this.proxies.get(target[p]);\n\t\t} else {\n\t\t\tresult = target[p];\n\t\t}\n\n\t\tif (this.serviceContext.renderingTracker.isRendering) {\n\t\t\tdebug('RS-listen:', currentRenderingComponentName(), propPath);\n\t\t\tthis.proxyContext.watches.add(propPath);\n\t\t} else {\n\t\t\tdebug('RS-ignore:', currentRenderingComponentName(), propPath);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tset(target: object, p: string | symbol, newValue: any, receiver: any): boolean {\n\t\tif (this.serviceContext.renderingTracker.isRendering) {\n\t\t\tthrow new Error('Trying to improperly set property: \"' + String(p) + '\" during a rendering. This will cause an infinite loop and is not allowed. Full path is \"' + this.pathForProp(p) + '\"');\n\t\t}\n\n\t\tnewValue = unwrapProxy(newValue);\n\n\t\tlet oldValue = target[p];\n\t\tif (Array.isArray(target)) {\n\t\t\tconst preLen = target.length;\n\t\t\tconst oldVal = target[p];\n\t\t\ttarget[p] = unwrapProxy(newValue);\n\n\t\t\tif (oldVal !== newValue) {\n\t\t\t\tconst path = this.pathForProp(p);\n\t\t\t\tthis.serviceContext.dispatcher.emit({path, oldValue, newValue});\n\t\t\t}\n\n\t\t\tif (target.length !== preLen) {\n\t\t\t\tconst path = this.pathForProp('length');\n\t\t\t\tthis.serviceContext.dispatcher.emit({path, oldValue: preLen, newValue: target.length});\n\t\t\t}\n\t\t} else {\n\t\t\ttarget[p] = unwrapProxy(newValue);\n\t\t\tif (oldValue !== newValue) {\n\t\t\t\tconst path = this.pathForProp(p);\n\t\t\t\tthis.serviceContext.dispatcher.emit({path, oldValue, newValue});\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate pathForProp(key: string | symbol) {\n\t\treturn this.path + '.' + String(key)\n\t}\n}\n", "import {AfterthoughtInjector, ServiceDefinitions, ValidServiceKey} from \"./types\";\nimport {createInjector} from \"./createInjector\";\nimport React, {createContext, useLayoutEffect, useRef} from \"react\";\n\nexport const AfterthoughtContext = createContext<AfterthoughtInjector>(null as any);\n\nexport function AfterthoughtProvider(props: {\n\tinjector?: never\n\tservices: ServiceDefinitions<any>\n\tchildren?: any\n} | {\n\tinjector: AfterthoughtInjector\n\tservices?: never\n\tchildren?: any\n}) {\n\tif(props.injector) {\n\t\treturn <AfterthoughtContext.Provider value={props.injector}>\n\t\t\t{props.children}\n\t\t</AfterthoughtContext.Provider>\n\t} else {\n\t\tconst injector = useRef(createInjector(props.services)).current;\n\t\treturn <AfterthoughtContext.Provider value={injector}>\n\t\t\t{props.children}\n\t\t</AfterthoughtContext.Provider>\n\t}\n}\n\n", "import {useInjector} from \"./useInjector\";\nimport {ToServiceInstance, AfterthoughtServices, ValidServiceKey} from \"../types\";\nimport {AfterthoughtService} from \"../AfterthoughtService\";\nimport {useEffect, useLayoutEffect, useRef, useState} from \"react\";\nimport {debug, getWatches} from \"../util/helpers\";\n\nexport function useService<TServices = AfterthoughtServices, T extends ValidServiceKey<TServices> = never>(serviceType: T): ToServiceInstance<T, TServices> {\n\tconst contextValue = useInjector<TServices>();\n\n\tconst serviceRef = useRef<any>(null);\n\tif (serviceRef.current === null) {\n\t\tserviceRef.current = contextValue.getService(serviceType);\n\t}\n\n\tconst service = serviceRef.current;\n\n\t// To track the rendering process we need to enter and exit our react services context\n\t// this is to know when we should add variables to our watch and when we cannot\n\tcontextValue._renderingTracker.notifyIsRendering();\n\n\tconst [, forceUpdate] = useState({});\n\tuseEffect(() => {\n\t\tconst sub = contextValue.subscribe(({path}) => {\n\t\t\tconst watchPaths = getWatches(service);\n\t\t\tif (watchPaths.has(path)) {\n\t\t\t\tdebug('RS-handle', watchPaths, path);\n\t\t\t\tforceUpdate({});\n\t\t\t} else {\n\t\t\t\tdebug('RS-see', watchPaths, path);\n\t\t\t}\n\t\t});\n\t\treturn () => {\n\t\t\tsub();\n\t\t}\n\t}, []);\n\n\treturn service as any;\n}\n"],
  "mappings": "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",
  "names": ["useContext", "SYM_PROXY_INDICATOR", "SYM_WATCHES", "AfterthoughtService", "createRenderingTracker", "handle", "getWatches", "service", "SYM_WATCHES", "debug", "args", "ListNode", "data", "__publicField", "node", "pn", "Dispatcher", "callback", "newNode", "createInjector", "services", "AfterthoughtInjectorImpl", "unwrapProxy", "obj", "v", "SYM_PROXY_INDICATOR", "config", "__publicField", "createRenderingTracker", "createServiceProxy", "Dispatcher", "key", "callback", "service", "context", "entry", "createProxyContext", "proxyHandler", "ObjectProxyHandler", "instance", "e", "_a", "injector", "proxyContext", "target", "p", "receiver", "newValue", "path", "serviceContext", "SYM_WATCHES", "result", "propPath", "debug", "oldValue", "preLen", "oldVal", "React", "createContext", "useRef", "AfterthoughtContext", "AfterthoughtProvider", "props", "injector", "createInjector", "useInjector", "useContext", "AfterthoughtContext", "useEffect", "useRef", "useState", "useService", "serviceType", "contextValue", "useInjector", "serviceRef", "useRef", "service", "forceUpdate", "useState", "useEffect", "sub", "path", "watchPaths", "getWatches", "debug"]
}
