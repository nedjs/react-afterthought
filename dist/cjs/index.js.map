{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/hooks/useInjector.ts", "../../src/util/helpers.ts", "../../src/util/Dispatcher.ts", "../../src/AfterthoughtService.ts", "../../src/createInjector.ts", "../../src/AfterthoughtProvider.tsx", "../../src/hooks/useService.ts"],
  "sourcesContent": ["export * from './types';\nexport * from './hooks';\nexport * from './AfterthoughtProvider';\nexport * from './AfterthoughtService';\nexport * from './createInjector';\n", "import {useContext} from \"react\";\nimport {AfterthoughtInjector, AfterthoughtServices} from \"../types\";\nimport {AfterthoughtContext} from \"../AfterthoughtProvider\";\n\nexport function useInjector<TService = AfterthoughtServices>(): AfterthoughtInjector<TService> {\n\tconst contextValue = useContext(AfterthoughtContext)\n\n\tif (__DEV__ && !contextValue) {\n\t\tthrow new Error(\n\t\t\t'could not find <TODO_NAME> context value; please ensure the component is wrapped in a <Provider>'\n\t\t)\n\t}\n\n\treturn contextValue as any;\n}\n", "import React from \"react\";\n\n// Our sneeky way of tracking rendering in react... it's not ideal at all\nexport const RS_CONTEXT = (() => {\n\tlet stack = [];\n\treturn {\n\t\tget current() {\n\t\t\treturn stack[stack.length-1];\n\t\t},\n\t\tenter(service: any) {\n\t\t\tstack.push(service);\n\t\t},\n\t\texit() {\n\t\t\tstack.pop();\n\t\t}\n\t};\n})();\n\n\n/**\n * Gets the current components name\n * @__PURE__\n * @internal\n */\nexport function currentRenderingComponentName(): string | undefined {\n\tif(!__DEV__) {\n\t\treturn undefined;\n\t} else {\n\t\treturn React['__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'].ReactCurrentOwner.current?.elementType?.name;\n\t}\n}\n\n/**\n * Lightweight logging\n * @internal\n * @param args\n */\nexport function debug(...args: any[]) {\n\tif(__DEV__) {\n\t\t// @ts-ignore\n\t\tconsole.debug(...args)\n\t}\n}\n", "import {ServiceHistory} from \"../types\";\n\nexport interface DispatchHandler<T> {\n\t(data: T): any;\n}\n\n/**\n * Basic doubly linked list, use this because it's easy to remove itself without affecting other nodes position\n */\nclass ListNode<T> {\n\tnext?: ListNode<T>\n\tprev?: ListNode<T>\n\n\tconstructor(\n\t\tpublic readonly data: T\n\t) {}\n\n\tadd(node: ListNode<T>) {\n\t\tconst pn = this.next;\n\t\tthis.next = node;\n\t\tnode.next = pn;\n\t\tnode.prev = this;\n\t}\n\n\tremoveSelf() {\n\t\tif(this.next)\n\t\t\tthis.next.prev = this.prev;\n\t\tif(this.prev)\n\t\t\tthis.prev.next = this.next;\n\n\t\tthis.next = undefined;\n\t\tthis.prev = undefined;\n\t}\n}\n\nexport class Dispatcher<T = ServiceHistory> {\n\tprivate readonly handlersHead = new ListNode<DispatchHandler<T>>(null);\n\n\temit(data: T) {\n\t\t// go next right away cause handlersHead is always a placeholder node\n\t\tlet node = this.handlersHead.next;\n\t\twhile(node) {\n\t\t\tnode.data(data);\n\t\t\tnode = node.next;\n\t\t}\n\t}\n\n\tsubscribe(callback: DispatchHandler<T>) {\n\t\tconst newNode = new ListNode(callback);\n\n\t\tthis.handlersHead.add(newNode);\n\n\t\treturn () => {\n\t\t\tnewNode.removeSelf();\n\t\t}\n\t}\n}\n", "import {AfterthoughtInjector, AfterthoughtServices} from \"./types\";\n\n/**\n * @internal - Private method for internal use only\n */\nexport const SYM_SERVICE_INIT = Symbol('rs_init');\n\n/**\n * @internal - Private method for internal use only\n */\nexport const SYM_SERVICE_WATCHES = Symbol('rs_watches');\n/**\n * @internal - Private method for internal use only\n */\nexport const SYM_SERVICE_PATH = Symbol('rs_path');\n\nexport class AfterthoughtService<TServices = AfterthoughtServices> {\n\n\tprivate _services: TServices;\n\n\tget services() {\n\t\treturn this._services;\n\t}\n\n\t/**\n\t * @internal\n\t * @param injector\n\t */\n\t[SYM_SERVICE_INIT](injector: AfterthoughtInjector<any>) {\n\t\tthis._services = injector.services as any;\n\t}\n\n\tstatic init(service: any, injector: AfterthoughtInjector<any>) {\n\t\tif(service[SYM_SERVICE_INIT]) {\n\t\t\tservice[SYM_SERVICE_INIT](injector);\n\t\t}\n\t}\n\n\tstatic getWatches(service: any): Set<string> | undefined {\n\t\tif(service && service[SYM_SERVICE_WATCHES]) {\n\t\t\treturn service[SYM_SERVICE_WATCHES];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tstatic getPath(service: any): Set<string> | undefined {\n\t\tif(service && service[SYM_SERVICE_PATH]) {\n\t\t\treturn service[SYM_SERVICE_PATH];\n\t\t}\n\t\treturn undefined;\n\t}\n}\n", "import {\n\tAfterthoughtInjector,\n\tToServiceInstance,\n\tAfterthoughtServices,\n\tClassConstructor, ValidServiceKey, ServiceHistory, ServiceInstances, ServiceDefinitions\n} from \"./types\";\nimport {\n\tcurrentRenderingComponentName,\n\tdebug,\n\tRS_CONTEXT\n} from \"./util/helpers\";\nimport {Dispatcher, DispatchHandler} from \"./util/Dispatcher\";\nimport {AfterthoughtService, SYM_SERVICE_WATCHES, SYM_SERVICE_PATH} from \"./AfterthoughtService\";\n\n\nexport function createInjector<TServices = AfterthoughtServices>(services: TServices): AfterthoughtInjector<TServices> {\n\treturn new CreateInjector<TServices>(services as any)\n}\n\nclass CreateInjector<TServices = AfterthoughtServices> implements AfterthoughtInjector<TServices> {\n\tprivate readonly serviceNames = new Map<string, any>();\n\tprivate readonly dispatcher = new Dispatcher();\n\tprivate readonly serviceInstances = new Map<any, {\n\t\tinstance: any,\n\t\ttype: any,\n\t\tname: string,\n\t}>;\n\n\tpublic readonly services: ServiceInstances<TServices> = new Proxy({}, new ServicesProxyHandler(this as AfterthoughtInjector<any>));\n\n\tconstructor(\n\t\tconfig: ServiceDefinitions<TServices>\n\t) {\n\t\tfor (let key in config) {\n\t\t\tthis.serviceNames.set(key, config[key]);\n\n\t\t\tthis.serviceInstances.set(config[key], {\n\t\t\t\tinstance: this.initService(config[key]),\n\t\t\t\ttype: config[key],\n\t\t\t\tname: key\n\t\t\t})\n\t\t}\n\n\n\t\tif(__DEV__) {\n\t\t\tthis.dispatcher.subscribe(({path}) => {\n\t\t\t\tdebug('RS-Change', path);\n\t\t\t})\n\t\t}\n\t}\n\n\tsubscribe(callback: DispatchHandler<ServiceHistory>): () => void {\n\t\treturn this.dispatcher.subscribe(callback);\n\t}\n\n\tgetService<T extends ValidServiceKey<TServices>>(service: T): ToServiceInstance<T, TServices> {\n\t\treturn this.initServiceProxy(service).proxy;\n\t}\n\n\tprivate initServiceProxy(service: ValidServiceKey<TServices>) {\n\t\tif (typeof service === 'string') {\n\t\t\tservice = this.serviceNames.get(service);\n\t\t}\n\n\t\tconst entry = this.serviceInstances.get(service);\n\t\tif (!entry) {\n\t\t\tthrow new Error('Unregistered service ' + String(service));\n\t\t}\n\n\t\tconst proxyHandler = new ObjectProxyHandler(entry.name, this.dispatcher)\n\n\t\treturn {\n\t\t\tproxy: new Proxy(entry.instance, proxyHandler),\n\t\t\tproxyHandler,\n\t\t};\n\t}\n\n\tprivate initService(service: ClassConstructor | object) {\n\t\tlet instance;\n\t\tif (this.isConstructor(service)) {\n\t\t\ttry {\n\t\t\t\tinstance = new service();\n\t\t\t} catch (e) {\n\t\t\t\tif (!e || e.name !== 'TypeError' ||\n\t\t\t\t\t!(typeof e.message === 'string' && e.message.endsWith('is not a constructor'))) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} else {\n\t\t\t\t\tinstance = service;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tinstance = service;\n\t\t}\n\n\t\tAfterthoughtService.init(instance, this as AfterthoughtInjector<any>);\n\t\treturn instance;\n\t}\n\n\tprivate isConstructor(v: any): v is new() => any {\n\t\treturn typeof v === 'function' && v?.prototype?.constructor\n\t}\n}\n\nclass ServicesProxyHandler implements ProxyHandler<any> {\n\tconstructor(\n\t\tprivate readonly injector: AfterthoughtInjector<any>\n\t) {\n\t}\n\n\tget(target: any, p: string | symbol, receiver: any): any {\n\t\tif (typeof p === 'string') {\n\t\t\treturn this.injector.getService(p);\n\t\t} else {\n\t\t\treturn target[p];\n\t\t}\n\t}\n\n\tset(target: any, p: string | symbol, newValue: any, receiver: any): boolean {\n\t\tthrow new Error('Cannot set a service here, services must be registered.')\n\t}\n}\n\nclass ObjectProxyHandler implements ProxyHandler<any> {\n\tpublic readonly proxies = new WeakMap<any, any>();\n\n\tconstructor(\n\t\tpublic readonly path: string,\n\t\tpublic readonly dispatcher: Dispatcher,\n\t\tpublic readonly watchPaths: Set<string> = new Set(),\n\t) {\n\t}\n\n\tget(target: object, p: string | symbol, receiver: any): any {\n\t\tif (target instanceof AfterthoughtService && AfterthoughtService.prototype.hasOwnProperty(p)) {\n\t\t\t// dont proxy types which exist on ReactiveService\n\t\t\tif(p === 'services') {\n\n\t\t\t}\n\t\t\treturn target[p];\n\t\t} else if(p === SYM_SERVICE_WATCHES) {\n\t\t\treturn this.watchPaths;\n\t\t} else if(p === SYM_SERVICE_PATH) {\n\t\t\treturn this.path;\n\t\t}\n\n\t\tlet result;\n\t\tconst propPath = this.pathForProp(p);\n\t\tif (typeof target[p] === 'function') {\n\t\t\tresult = target[p];\n\t\t} else if (target[p] !== null && typeof target[p] === 'object') {\n\t\t\tif (!this.proxies.has(target[p]) || this.proxies.get(target[p]) == null) {\n\t\t\t\tthis.proxies.set(target[p], new Proxy(target[p], new ObjectProxyHandler(propPath, this.dispatcher, this.watchPaths)));\n\t\t\t}\n\t\t\tresult = this.proxies.get(target[p]);\n\t\t} else {\n\t\t\tresult = target[p];\n\t\t}\n\n\t\tif (RS_CONTEXT.current) {\n\t\t\tdebug('RS-listen:', currentRenderingComponentName(), propPath);\n\t\t\tAfterthoughtService.getWatches(RS_CONTEXT.current).add(propPath);\n\t\t} else {\n\t\t\tdebug('RS-ignore:', currentRenderingComponentName(), propPath);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tset(target: object, p: string | symbol, newValue: any, receiver: any): boolean {\n\t\tif (RS_CONTEXT.current) {\n\t\t\tthrow new Error('Trying to improperly set property: \"' + String(p) + '\" during a rendering. This will cause an infinite loop and is not allowed. Full path is \"' + this.pathForProp(p) + '\"');\n\t\t}\n\n\t\tlet oldValue = target[p];\n\t\tif (Array.isArray(target)) {\n\t\t\tconst preLen = target.length;\n\t\t\tconst oldVal = target[p];\n\t\t\ttarget[p] = newValue;\n\n\t\t\tif (oldVal !== newValue) {\n\t\t\t\tconst path = this.pathForProp(p);\n\t\t\t\tthis.dispatcher.emit({path, oldValue, newValue});\n\t\t\t}\n\n\t\t\tif (target.length !== preLen) {\n\t\t\t\tconst path = this.pathForProp('length');\n\t\t\t\tthis.dispatcher.emit({path, oldValue: preLen, newValue: target.length});\n\t\t\t}\n\t\t} else {\n\t\t\ttarget[p] = newValue;\n\t\t\tif (oldValue !== newValue) {\n\t\t\t\tconst path = this.pathForProp(p);\n\t\t\t\tthis.dispatcher.emit({path, oldValue, newValue});\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate pathForProp(key: string | symbol) {\n\t\treturn this.path + '.' + String(key)\n\t}\n}\n", "import {AfterthoughtInjector, ServiceDefinitions, ValidServiceKey} from \"./types\";\nimport {createInjector} from \"./createInjector\";\nimport React, {createContext, useRef} from \"react\";\n\nexport const AfterthoughtContext = createContext<AfterthoughtInjector>(null as any);\n\nexport function AfterthoughtProvider(props: {\n\tinjector?: never\n\tservices: ServiceDefinitions<any>\n\tchildren?: any\n} | {\n\tinjector: AfterthoughtInjector\n\tservices?: never\n\tchildren?: any\n}) {\n\tif(props.injector) {\n\t\treturn <AfterthoughtContext.Provider value={props.injector}>\n\t\t\t{props.children}\n\t\t</AfterthoughtContext.Provider>\n\t} else {\n\t\tconst injector = useRef(createInjector(props.services)).current;\n\t\treturn <AfterthoughtContext.Provider value={injector}>\n\t\t\t{props.children}\n\t\t</AfterthoughtContext.Provider>\n\t}\n}\n\n", "import {useInjector} from \"./useInjector\";\nimport {ToServiceInstance, AfterthoughtServices, ValidServiceKey} from \"../types\";\nimport {AfterthoughtService} from \"../AfterthoughtService\";\nimport {useEffect, useLayoutEffect, useRef, useState} from \"react\";\nimport {debug, RS_CONTEXT} from \"../util/helpers\";\n\nexport function useService<TServices = AfterthoughtServices, T extends ValidServiceKey<TServices> = never>(serviceType: T): ToServiceInstance<T, TServices> {\n\tconst contextValue = useInjector<TServices>();\n\n\tconst serviceRef = useRef<any>(null);\n\tif (serviceRef.current === null) {\n\t\tserviceRef.current = contextValue.getService(serviceType);\n\t}\n\n\tconst service = serviceRef.current;\n\n\t// To track the rendering process we need to enter and exit our react services context\n\t// this is to know when we should add variables to our watch and when we cannot\n\tRS_CONTEXT.enter(service);\n\tuseLayoutEffect(() => {\n\t\tRS_CONTEXT.exit();\n\t});\n\n\tconst [, forceUpdate] = useState({});\n\tuseEffect(() => {\n\t\tconst sub = contextValue.subscribe(({path}) => {\n\t\t\tconst watchPaths = AfterthoughtService.getWatches(service);\n\t\t\tif (watchPaths.has(path)) {\n\t\t\t\tdebug('RS-handle', watchPaths, path);\n\t\t\t\tforceUpdate({});\n\t\t\t} else {\n\t\t\t\tdebug('RS-see', watchPaths, path);\n\t\t\t}\n\t\t});\n\t\treturn () => {\n\t\t\tsub();\n\t\t}\n\t}, []);\n\n\treturn service as any;\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "AfterthoughtContext", "AfterthoughtProvider", "AfterthoughtService", "SYM_SERVICE_INIT", "SYM_SERVICE_PATH", "SYM_SERVICE_WATCHES", "createInjector", "useInjector", "useService", "__toCommonJS", "import_react", "import_react", "RS_CONTEXT", "stack", "service", "debug", "args", "ListNode", "data", "__publicField", "node", "pn", "Dispatcher", "callback", "newNode", "SYM_SERVICE_INIT", "SYM_SERVICE_WATCHES", "SYM_SERVICE_PATH", "AfterthoughtService", "__publicField", "injector", "service", "createInjector", "services", "CreateInjector", "config", "__publicField", "Dispatcher", "ServicesProxyHandler", "key", "callback", "service", "entry", "proxyHandler", "ObjectProxyHandler", "instance", "e", "AfterthoughtService", "v", "_a", "injector", "target", "p", "receiver", "newValue", "path", "dispatcher", "watchPaths", "SYM_SERVICE_WATCHES", "SYM_SERVICE_PATH", "result", "propPath", "RS_CONTEXT", "debug", "oldValue", "preLen", "oldVal", "import_react", "AfterthoughtContext", "AfterthoughtProvider", "props", "React", "injector", "createInjector", "useInjector", "AfterthoughtContext", "import_react", "useService", "serviceType", "contextValue", "useInjector", "serviceRef", "service", "RS_CONTEXT", "forceUpdate", "sub", "path", "watchPaths", "AfterthoughtService", "debug"]
}
